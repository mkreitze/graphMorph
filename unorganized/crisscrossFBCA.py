# This code (made as of Nov 2020) is meant to utilize 'crisscrossing' to generate complex level-maps.

# 

#imports of libraries
import libFBCAGen
import os 
import itertools

##INITS 
#defintions for FBCA generation
libFBCAGen.CALength=100 #Length of the generated image (for min use 5)
libFBCAGen.CAWidth=100 #Width of the generated image (for min use 4)
libFBCAGen.useImages=0 #generate gifs? 
libFBCAGen.finalImage=0 #generate final level map?
libFBCAGen.numOfGens=20 #number of generations
libFBCAGen.random.seed(1) #set to 1 for constant
d=[];d=os.getcwd()+"/" #Get directory
#Score matrix inits
sM1=[0.320205,0.952292,0.351335,0.837774]
sM2=[0.390741,0.728013,0.614486,0.378596]
#sM3=[0.420,0.69,0.1337,0.8008]
sMs=[sM1,sM2]
#generate first guys
libFBCAGen.numOfStates=int(len(sM1)/2)
CAMapInit=[];CAMapInit=libFBCAGen.initCA(CAMapInit) #Get L_0
for idx,curSM in enumerate(sMs):    
    libFBCAGen.generateFBCA(curSM,d,CAMapInit,str(idx)) #Generate the final L_g
#get ready for the increased dim
libFBCAGen.numOfStates=len(sM1) #number of states (its assumed the set of score matrices given are all the same dimension)
numOfSpots=len(sM1)
numOfStates=len(sMs)
quantifer="test"
CAMapInit=[];CAMapInit=libFBCAGen.initCA(CAMapInit) #Get L_0

# Generates crisscrossed matrices #
### Input: the score matrices used to crissCross, the configuration of score matrices, the iteration number,
### Output: a 2*n number of state score matrix crissCrossed
# Notes:
# The configuration of score matrices is generated by a list of ints such as [1,2,2,1] 
# The string 1,2,2,1 generates a score matrix of 2*n dimensions 
def crissCross(sMs,ints,n=0):
    newScoreMatrix=[]
    for x in ints:
        newScoreMatrix+=(sMs[x-1]) #tacks on the end part of the list to the score matrices
    return(newScoreMatrix)

#de Bruijn sequence generator
#This is shamelessly stolen from https://codegolf.stackexchange.com/questions/42728/generate-the-shortest-de-bruijn 
#This would take a while to come up on my own with... thanks mbomb007
#I slightly modified it
def f(a,n):
    s=a[-1]*n
    while 1:
        for c in a:
            p=s+c
            if p[len(p)-n:]in s:
                continue
            else:
                s=p
                break
        else:
            break
    return(s[:1-n])


crissCrossSMs=[]
posStates=""
for x in range(numOfStates):
    posStates+=str(x)
allStrings=f(posStates,4)
#Print it off as a record
crissCrossRecord = open(f"crissCross {quantifer}", "w")

for x in range(len(allStrings)):
    curString=[]
    for y in range(numOfSpots):
        curString.append(int(allStrings[(x+y)%(len(allStrings))]))
    curSM=[]
    curSM=crissCross(sMs,curString) #Generate the score matrix
    crissCrossSMs.append(curSM) #"Your score matrice's will make a fine addition to my collection" - General CrissCross
    libFBCAGen.generateFBCA(curSM,d,CAMapInit,curString) #Generate the final L_g
    crissCrossRecord.write(f"crissCross Str:{curString} sM:{curSM} \n")
